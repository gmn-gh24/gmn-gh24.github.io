Skip to content
Chat history


You said:
Find out everything you can about Atera RMM API and what we can do with it and powershell
ChatGPT said:
To tailor the research precisely, could you please clarify:

What are your main goals with the Atera RMM API (e.g., automation, device management, ticketing integration)?

Are you looking for specific PowerShell use cases or a general overview of capabilities?

Do you need examples of PowerShell scripts using the Atera API?

Are there specific Atera modules or features you're most interested in (e.g., alerts, patching, reporting)?

This will help me focus the research on what's most useful for your workflow.

You said:
1 all of the above
2 general overview and capabilities
3 yes, detailed examples, commented
4 I want to know about all available modules and what we can do with them
ChatGPT said:
Understood. I will compile a comprehensive overview of the Atera RMM API, including its available modules and capabilities, and demonstrate how to leverage it using PowerShell. This will include detailed, well-commented script examples for practical automation, device and ticket management, alerting, patching, reporting, and more.

I'll get started and let you know as soon as the findings are ready.

Atera RMM API Capabilities and PowerShell Integration

Atera RMM API Capabilities and PowerShell Integration
Atera‚Äôs Remote Monitoring and Management (RMM) platform provides a comprehensive REST API (current version 3) that allows automation and integration across its modules. The API is secured by a unique API access key that you must include with every request (e.g. via an HTTP header)
support.atera.com
powershellgallery.com
. All API calls use HTTPS and return JSON data. Below is an overview of the API‚Äôs modules and capabilities, followed by practical PowerShell examples demonstrating how to authenticate and use these endpoints for device management, alerts, ticketing, scripting, patching, reporting, and more.
Atera API Modules and Capabilities
Device Management (Agents and Network Devices): The API enables management of agent-installed devices (computers/servers with the Atera agent) as well as monitored network devices (SNMP, HTTP, TCP, etc.). For agents, you can retrieve the list of all devices (GET /api/v3/agents), query specific agents by ID or customer, and even remove (off-board) an agent (DELETE /api/v3/agents/{agentId})
github.com
github.com
. Agent records include detailed information such as Agent/Machine ID, customer assignment, device name, hardware specs (CPU, RAM, motherboard, etc.), network details (IP and MAC addresses), OS version, last logged-in user, and online/offline status
community.atera.com
. (Note: Installing a new agent is done via the Atera installer, not directly through the API, though a PowerShell helper can download and run the installer
powershellgallery.com
powershellgallery.com
.) For network devices without an agent, the API provides endpoints to create and manage monitoring devices ‚Äì for example, you can POST /api/v3/devices/snmpdevice/v3 to add an SNMP-monitoring device, or GET /api/v3/devices/httpdevices to list all HTTP monitors
github.com
github.com
. There are separate endpoints for each monitor type (Generic, SNMP v1/v2/v3, HTTP, TCP), supporting creation, retrieval, and deletion
github.com
github.com
. This allows you to script the addition of new network devices and retrieve their status via the API. Alerts and Monitoring: Atera supports real-time monitoring alerts (e.g. triggered by thresholds or issues on devices), and the API allows full access to alert data. You can list alerts (GET /api/v3/alerts) or retrieve a specific alert by ID
github.com
, including details like Alert Code, Source, Title, Severity (Info/Warning/Critical), timestamps, device info, and whether it‚Äôs been archived (resolved)
stackoverflow.com
stackoverflow.com
. The API also lets you create new alerts (POST /api/v3/alerts) programmatically
github.com
 ‚Äì for instance, to trigger a custom alert from an external system. Each alert can be acknowledged/resolved by essentially deleting or archiving it: calling DELETE /api/v3/alerts/{alertId} will mark the alert as resolved/removed
github.com
. (When an alert is cleared, Atera sets an ‚ÄúArchived‚Äù flag and timestamp in its data
stackoverflow.com
.) The API covers alert fields such as SnoozedEndDate (if an alert was snoozed), AlertMessage (detailed description), associated Device and Customer IDs, and even links to a ticket if one was generated from the alert
stackoverflow.com
. This enables integration with external notification systems or custom dashboards ‚Äì for example, you could use the API to feed alerts into Slack/Teams or your own monitoring board
support.atera.com
. Ticketing (Helpdesk) and PSA: Atera‚Äôs PSA (Professional Services Automation) features ‚Äì including helpdesk tickets ‚Äì are fully accessible via the API. You can retrieve tickets (GET /api/v3/tickets) with optional query parameters to filter by Customer or status
reddit.com
, get a specific ticket by ID, and pull related data like ticket comments or work hours. The API supports creating new tickets (POST /api/v3/tickets) as well as updating existing tickets (PUT /api/v3/tickets/{ticketId}) and deleting tickets
support.atera.com
. All CRUD operations are available for tickets
support.atera.com
, meaning you can open tickets, modify their properties, and close or remove them via script. Common ticket fields include TicketID, Title, Description, Priority, Status, Type, Impact, associated Contact (end-user) info, timestamps (creation, resolution), etc.
support.atera.com
. The API also provides specialized endpoints for ticket sub-resources: for example, GET /api/v3/tickets/{ticketId}/comments returns the list of ticket comments, and GET /api/v3/tickets/{ticketId}/workhoursrecords returns time entries (work hours logged) on the ticket
github.com
github.com
. This enables powerful integrations; for instance, you could auto-create tickets from an external form or close tickets in bulk. In fact, the API documentation confirms you can update key fields like TicketStatus, TicketPriority, TicketType, TicketImpact, or reassign the technician (TechnicianContactID) via the ticket update call
reddit.com
. (For example, setting TicketStatus to ‚ÄúResolved‚Äù via API will mark the ticket as resolved.) You can also filter queries by status ‚Äì e.g. get only ‚ÄúOpen‚Äù tickets for a client or only ‚ÄúResolved‚Äù ones ‚Äì using query parameters CustomerId and ticketStatus on the GET request
reddit.com
. Customers and Contacts: The API allows management of your customer organizations and end-user contacts. Customers can be retrieved (GET /api/v3/customers for all or by ID) and created or updated (POST /api/v3/customers and PUT /api/v3/customers/{id})
github.com
github.com
. Through the API you can obtain customer details such as name, address/domain, creation date, and custom fields
support.atera.com
. There are also endpoints to organize customers into folders (POST /api/v3/customers/folders) and even attach files to a customer record (POST /api/v3/customers/attachments)
github.com
github.com
. Contacts (individual end users or employees under a customer) similarly support full CRUD: list contacts, get by ID, create new contacts, edit or delete them
github.com
github.com
. For instance, you might use POST /api/v3/contacts to add a new end-user with fields like name, email, phone, etc., or update a contact‚Äôs details via PUT
github.com
github.com
. This is useful for syncing Atera with an external CRM or user directory. Contact objects include properties such as EndUserID, CustomerID (association), name, email, phone, job title and so on
support.atera.com
. Contracts and Billing: Atera‚Äôs API covers core PSA financial data as well. You can retrieve contracts (GET /api/v3/contracts) to see support plan details for customers, including each contract‚Äôs name, type (e.g. hourly vs. fixed), start/end dates, and status
github.com
github.com
. You can filter contracts by customer (/contracts/customer/{customerId}) or get a specific contract by ID
github.com
. (At present, contract information is read-only via API; there are no calls to create/update contracts.) For billing, the API provides access to invoice records ‚Äì GET /api/v3/billing/invoices returns a list of invoices, and GET /api/v3/billing/invoice/{invoiceNumber} fetches a specific invoice by number
github.com
. This includes fields like InvoiceID, number, total, subtotal, tax, etc., allowing integration with accounting systems
support.atera.com
. Additionally, the Rates endpoints let you manage billable products and expenses: you can list products or expenses (GET /api/v3/rates/products or /expenses), create new ones (POST), update or delete them
github.com
github.com
. This helps keep your service catalog in sync via automation. Custom Fields (Custom Values): Atera allows custom fields on various entities (customers, agents/devices, contacts, tickets, etc.), and the API exposes these through CustomValues endpoints. You can retrieve the value of a custom field for a given object, e.g. GET /api/v3/customvalues/customerfield/{customerId}/{fieldName} to get a customer‚Äôs custom field
github.com
github.com
, or .../agentfield/{agentId}/{fieldName} for an agent device‚Äôs custom field
github.com
. The response will include the field name and the value (with type information like string, decimal, or boolean)
reddit.com
reddit.com
. The API also supports updating custom field values ‚Äì for instance, PUT /api/v3/customvalues/ticketfield/{ticketId}/{fieldName}/{value} will set a custom field on a ticket
github.com
. All major object types are supported (agents, contacts, customers, contracts, SLAs, devices of each monitor type, tickets, etc.) with dedicated endpoints for each
github.com
github.com
. This is particularly useful for automation scripts; for example, you might store a license key or configuration value in a custom field and use the API to fetch it from a script running on the endpoint (as demonstrated later). Knowledge Base: If you use Atera‚Äôs knowledge base for documentation or solutions, the API can retrieve those articles. GET /api/v3/knowledgebases returns the list of KB articles (with fields like KBID, title, last modified time, etc.)
support.atera.com
. This allows you to export or sync your knowledge base content to another system or website. (The API is currently read-only for the KB; creating or editing articles is done via the web interface.) Automation and Scripting: Atera includes powerful IT automation profiles (for scheduled tasks, patching, script execution, etc.), but these are primarily configured via the UI rather than through open API calls. The public API does not yet provide direct endpoints to run a script on-demand on an agent or to schedule automation profiles. Instead, scripts are typically executed by assigning them to devices through automation profiles in the web console
support.atera.com
. For example, you might schedule a script to run weekly on all workstations via an automation profile (this cannot be triggered via API at this time). That said, the API can be leveraged within scripts to enhance automation. A common pattern is to use the API from a PowerShell script running on an endpoint to retrieve or send data. For instance, a script running on an agent can call Atera‚Äôs API to get a custom field value (such as a stored license key or configuration) and then perform an action with it
support.atera.com
. We demonstrate this below. In summary, while you cannot directly invoke ‚Äúrun script on device X now‚Äù through the API, you can automate nearly everything around it ‚Äì device info, alerts, ticket creation, and using custom field data in scripts ‚Äì to support your IT Automation needs. (Note: Atera‚Äôs roadmap may expand API endpoints for automation in the future, but as of now scheduling patch jobs or script tasks is done via the UI)
community.atera.com
community.atera.com
. Patch Management: Similar to scripting, patch management in Atera is primarily handled by automation profiles and the agent software, rather than direct API calls. There is no public API call to force a patch scan or deployment on demand. However, the API does expose patch status information. Each agent record includes fields like LastPatchManagementReceived (timestamp of the last patch cycle)
community.atera.com
, which you can use to audit whether devices are updating. You can also use scripting (via the agent or remote shell) to install software or patches and use the API to log the outcome (e.g. create an alert or ticket if a patch job failed). Additionally, Atera offers a software installation feature (third-party software patching) as part of automation profiles
support.atera.com
, but again, triggering those installations via API is not supported. In practice, to perform software deployment or patching with Atera programmatically, a common approach is to use the API in combination with scripts: for example, use the API to retrieve a list of machines needing a certain software, then remotely execute a script (through Atera‚Äôs scheduling or another remote execution method) to install it, and perhaps use the API to report success (by creating a ticket or alert). In summary, patching and software installs are automated within Atera‚Äôs system (scheduling, profiles) and not directly by API calls ‚Äì the API serves for reporting and ancillary actions around those tasks. Reporting and Data Access: Virtually all data you see in the Atera UI (devices, alerts, tickets, etc.) can be pulled via the API, which means you can create custom reports and dashboards. There are not ‚Äúpre-canned‚Äù report endpoints, but you have the building blocks: e.g. you can retrieve all agent data to build an inventory report, or query ticket metrics to build an SLA report. For instance, Atera provides a special endpoint GET /api/v3/tickets/statusmodified which returns tickets that were recently resolved or closed
github.com
 ‚Äì this can help in reporting how many tickets were closed in a period. You can also get time entries on tickets (work hours) for timesheet reports, alert statistics, customer lists, and so on. The API uses pagination for large datasets, so keep that in mind when aggregating data. By default, requests return 20‚Äì50 items per page (the default is often 20)
stackoverflow.com
, along with a totalItemCount and a nextLink URL for the next page of results
stackoverflow.com
. You‚Äôll need to loop through pages by following nextLink until it‚Äôs empty (or use the page and itemsInPage query parameters manually)
stackoverflow.com
. This approach is how you can extract all records for reporting. (For example, a Power BI integration would iterate through pages of /agents or /tickets to pull everything
community.atera.com
community.atera.com
.) Rate limits do exist (Atera allows a few hundred requests per minute depending on your tier)
support.atera.com
, but these are quite generous for typical reporting needs. In summary, the Atera API covers a wide range of functions: device and agent info, alerts, ticketing, contact and customer management, billing data, and more. With it you can integrate Atera with other systems (e.g. create tickets from an external form, sync contacts with an HR system, send alerts to Slack or Teams)
support.atera.com
, or automate tasks by writing scripts that query and update Atera. Below, we‚Äôll demonstrate how to use the Atera API with PowerShell, including authenticating with the API key, querying devices, managing alerts and tickets, and other practical examples.
PowerShell Integration Examples
The following examples show how to connect to the Atera API using PowerShell and perform common tasks. Each script is annotated with comments (#) to explain what it‚Äôs doing. Before running these, make sure you have your Atera API key available (from the Atera Admin > API section) and consider storing it securely (e.g. in an environment variable or secure vault). In these examples, we‚Äôll use a variable for the API key for simplicity.
1. Authenticating to the Atera API in PowerShell
To authenticate, use your API key in the header of each HTTP request. Atera expects the key in an X-API-KEY header (and ensure the request Accepts JSON). We can use Invoke-RestMethod or Invoke-WebRequest for REST calls in PowerShell. Below is a snippet to set up the header and test the connection by fetching the current account‚Äôs customer list:
# Your Atera API key (replace with your actual key, or retrieve from a secure source)
$AteraApiKey = "YOUR_API_KEY_HERE"

# Prepare the headers for API requests, including the API key and JSON accept header
$headers = @{
    "X-API-KEY" = $AteraApiKey          # API authentication key for Atera:contentReference[oaicite:67]{index=67}
    "Accept"   = "application/json"     # Ensure the response is JSON
}

# Test the connection by requesting a list of customers (GET /api/v3/customers)
$customers = Invoke-RestMethod -Uri "https://app.atera.com/api/v3/customers" -Method GET -Headers $headers

# Output the total number of customers retrieved and the first customer's name as a sample
Write-Host "Connected. Retrieved $($customers.totalItemCount) customers. First customer:" $customers.items[0].CustomerName
Explanation: We construct a $headers hashtable with the required API key. The script then calls the /customers endpoint to fetch all customers. If authentication is successful, $customers.items will contain an array of customer objects. We print out the count and an example name. (If the API key is incorrect or missing, you would get an HTTP 401 Unauthorized error.) This forms the basis for all subsequent calls ‚Äì we‚Äôll reuse the $headers for each request.
2. Querying Device Inventory and Status
One of the most common uses of the API is to retrieve the device inventory. The Agents endpoint (/api/v3/agents) returns all devices with the Atera agent installed, including their details and status. Since the list can be large, the API paginates results (defaults to 20 per page). We‚Äôll retrieve all agents by looping through pages, then output some key info for each device (name, online status, OS, etc.):
# Function to get all agents by iterating through pages
function Get-AllAteraAgents {
    $allAgents = @()
    $page = 1
    $pageSize = 50           # Number of items per page (max 50 recommended for Atera API)
    do {
        $uri = "https://app.atera.com/api/v3/agents?page=$page&itemsInPage=$pageSize"
        $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method GET
        $allAgents += $response.items
        $page += 1
    } while ($response.nextLink -ne $null -and $response.nextLink -ne "")
    return $allAgents
}

$agents = Get-AllAteraAgents
Write-Host "Total agents retrieved:" $agents.Count

# Example: list each agent's name, customer, and online status
foreach ($agent in $agents) {
    $status = if ($agent.Online) {"Online"} else {"Offline"}
    Write-Host "Device:" $agent.AgentName " | Customer:" $agent.CustomerName " | Status:" $status " | OS:" $agent.OS
}
Explanation: This script defines a helper function to fetch all agents by looping through each page of results. We specify itemsInPage=50 to get 50 agents per call (Atera‚Äôs max page size is typically 50)
community.atera.com
community.atera.com
. We use the nextLink provided in each response to determine if there are more pages
stackoverflow.com
. After collecting all agent records in $agents, we output some details for each. Each $agent object contains many properties ‚Äì for example:
AgentName / MachineName ‚Äì the device‚Äôs name (as seen in Atera)
community.atera.com
CustomerName ‚Äì which customer the device is assigned to
community.atera.com
Online ‚Äì boolean indicating if the agent is currently online
community.atera.com
OS ‚Äì operating system name/version (e.g. Windows 11 Pro)
community.atera.com
community.atera.com
IPAddress/MacAddresses ‚Äì the last reported IP and MAC(s) of the device
community.atera.com
community.atera.com
Processor/Memory ‚Äì CPU model and total RAM
community.atera.com
, etc.
Using this data, you could generate a custom inventory report or feed it into another system. (For brevity, we only printed a few fields above, but you have access to dozens of properties for each agent ‚Äì such as last reboot time, agent version, hardware details, etc. ‚Äì via the API
community.atera.com
community.atera.com
.) You can also query specific subsets of devices directly. For example, to get agents for a particular customer only, you can call GET /api/v3/agents/customer/{customerId} (which returns just those agents)
github.com
. Or if you know a machine‚Äôs name, GET /api/v3/agents/machine/{machineName} finds the agent record(s) for that hostname
github.com
. These specialized endpoints can save you from filtering in code.
3. Managing Alerts (Create, Acknowledge, Resolve)
Next, let‚Äôs handle alerts via PowerShell. In Atera, alerts are generated by monitoring conditions (e.g. high CPU, offline device, etc.), but we can also manipulate them through the API. Common tasks include retrieving current alerts, acknowledging or resolving alerts, and even creating new alerts. a. Retrieving Alerts: To get all active alerts, use GET /api/v3/alerts. For example:
# Fetch all active alerts 
$alertsResponse = Invoke-RestMethod -Uri "https://app.atera.com/api/v3/alerts" -Headers $headers -Method GET
$alerts = $alertsResponse.items
Write-Host "Total alerts:" $alertsResponse.totalItemCount

# List alerts with some key info
foreach ($alert in $alerts) {
    Write-Host "[Alert #$($alert.AlertID)] $($alert.Severity): $($alert.Title) on $($alert.DeviceName) (Customer: $($alert.CustomerName))"
}
This will output each alert‚Äôs ID, severity, title, and the device/customer it pertains to. The alert objects include many properties, such as Code (an internal code or event ID), Source (which system or monitor generated it), Created timestamp, and flags like Archived (true if the alert was resolved/archived)
stackoverflow.com
 or SnoozedEndDate (if the alert is snoozed until a certain time)
stackoverflow.com
. You can filter alerts by severity or other criteria in PowerShell easily. For example, to get only critical alerts:
$criticalAlerts = $alerts | Where-Object { $_.Severity -eq "Critical" }
b. Acknowledging/Resolving Alerts: Atera does not have a separate ‚Äúacknowledge‚Äù action via API; effectively, resolving an alert can be done by deleting it (which archives it). To clear a specific alert, call DELETE /api/v3/alerts/{alertId}. For instance:
# Acknowledge/resolve an alert by deleting it
$alertId = 123456  # replace with the actual AlertID you want to resolve
Invoke-RestMethod -Uri "https://app.atera.com/api/v3/alerts/$alertId" -Headers $headers -Method DELETE
Write-Host "Alert $alertId has been marked as resolved (deleted)."
After this call, the alert will no longer appear in the active alerts list (in the UI it moves to archived alerts). The API will respond with a confirmation (usually no content for delete, just a 204 status). Internally, Atera will mark the alert‚Äôs Archived status as true and set an ArchivedDate
stackoverflow.com
. c. Creating an Alert: You can create an alert programmatically using POST /api/v3/alerts. This might be useful if an external system needs to raise an alert in Atera (for example, a custom script detects an issue and creates an Atera alert for it). To do this, you need to send a JSON body with alert details. According to Atera‚Äôs API, required fields include at least a Title, Severity, and typically some identifier of the device or context. Here‚Äôs an example:
# Create a new custom alert in Atera
$newAlert = @{
    Title       = "Custom Alert: Backup Failed"     # Short alert title
    Severity    = "Critical"                        # Severity level: Information, Warning, Critical
    AlertMessage= "Nightly backup did not complete on server XYZ."  # detailed description
    CustomerID  = 1001                              # ID of the customer (tenant) relevant to the alert
    AgentID     = 2002                              # (optional) ID of the agent device if applicable
    Source      = "ExternalScript"                  # Source of the alert (could be any string identifier)
    Code        = 9001                              # (optional) Custom code for the alert type
}
$response = Invoke-RestMethod -Uri "https://app.atera.com/api/v3/alerts" -Headers $headers `
            -Method POST -Body ($newAlert | ConvertTo-Json)
Write-Host "Created alert, received AlertID:" $response.AlertID
In this example, we create an alert about a backup failure. We include CustomerID so it appears under that customer‚Äôs alerts. If the alert pertains to a specific monitored agent, include the AgentID (or for a network device, you might include a DeviceGuid or other identifier). The API will respond with the created alert object, including the new AlertID. Once created, this alert will behave like any other ‚Äì it can trigger email notifications (if configured in Atera) and can be resolved by a technician (or via the API as shown above).
4. Retrieving and Managing Tickets via API
The ticketing API allows you to integrate your helpdesk with other tools or automate ticket workflows. Let‚Äôs look at a few scenarios: querying tickets, updating a ticket‚Äôs status, and creating a new ticket. a. Querying Tickets: To retrieve tickets, use GET /api/v3/tickets. By default, this returns all tickets (paginated). Often you‚Äôll want to filter by status or customer. The API supports query parameters for this. For example, to get open tickets for a specific customer, you can do:
# Get all "open" (unresolved) tickets for a given customer
$customerId = 1001
$ticketsResponse = Invoke-RestMethod -Uri "https://app.atera.com/api/v3/tickets?CustomerId=$customerId&ticketStatus=Open" `
                                     -Headers $headers -Method GET
$tickets = $ticketsResponse.items
Write-Host "Open tickets for Customer $customerId:" $ticketsResponse.totalItemCount

foreach ($t in $tickets) {
    Write-Host "[Ticket #$($t.TicketID)] $($t.TicketTitle) - Status: $($t.TicketStatus) - Created: $($t.CreatedOn)"
}
In the query string we used CustomerId and ticketStatus filters
reddit.com
. The ticketStatus parameter can be set to statuses like ‚ÄúOpen‚Äù, ‚ÄúPending‚Äù, ‚ÄúResolved‚Äù, ‚ÄúClosed‚Äù (as text). This helps narrow down results on the server side. In our loop, each ticket object has properties like TicketID, TicketTitle, TicketStatus, CreatedOn, EndUserEmail (requester), Technician (assignee), etc.
support.atera.com
. You can adjust the output as needed (e.g. list only high-priority tickets, or group by technician). If you need all tickets across all customers, you can omit filters and page through results similar to the agent example. b. Updating Ticket Status (Resolving Tickets): Suppose you want to programmatically close or resolve a ticket (perhaps because your automation fixed the issue, or you‚Äôre syncing statuses from another system). Atera allows updating certain fields via PUT /api/v3/tickets/{ticketId}. As noted in their documentation, you can update fields such as TicketStatus, Title, Priority, Impact, Type, and Technician assignment
reddit.com
. To mark a ticket as Resolved:
# Resolve a ticket via API by updating its status
$ticketId = 12345
$updateBody = @{
    TicketStatus = "Resolved"    # Set status to Resolved (could also be "Closed" depending on your workflow)
    ResolutionDescription = "Issue fixed by automated script."  # Optionally add a resolution note
}
Invoke-RestMethod -Uri "https://app.atera.com/api/v3/tickets/$ticketId" -Headers $headers `
                 -Method PUT -Body ($updateBody | ConvertTo-Json)
Write-Host "Ticket $ticketId status updated to Resolved."
We send a JSON with the fields to change. In this case, we set TicketStatus. Atera will accept common status names (like Resolved, Closed, etc.) or their internal codes. After this call, the ticket‚Äôs status changes accordingly in the Atera system. We also included a ResolutionDescription which adds an internal note about how it was resolved. (You could also update other fields similarly ‚Äì for example, change TicketPriority or assign TechnicianContactID to a different tech by ID in the same payload
reddit.com
.) c. Creating a New Ticket: You can also create tickets via API (which is useful for integrating contact forms, monitoring systems, or chatbots to open tickets automatically). Use POST /api/v3/tickets with a JSON body providing at least the required fields (typically Title, Description, Contact and/or Customer). Here‚Äôs an example:
# Create a new ticket via API
$newTicket = @{
    CustomerID    = 1001                   # The customer organization ID
    ContactID     = 5678                   # The end-user contact who reported the issue (EndUserID)
    TicketTitle   = "Automated Issue Report - Server Room Temp High"
    TicketDescription = "This ticket was created by a monitoring script. The server room temperature exceeded the threshold."
    TicketPriority= "High"
    TicketType    = "Incident"
}
$response = Invoke-RestMethod -Uri "https://app.atera.com/api/v3/tickets" -Headers $headers `
            -Method POST -Body ($newTicket | ConvertTo-Json)
Write-Host "Created Ticket #$($response.TicketID) for customer $($response.CustomerID)."
In this payload, we specified which customer and contact the ticket is for, gave it a title and description, and set a priority and type. You could also set other fields like TicketImpact or attach files via separate calls if needed. The API returns the created ticket object with its new TicketID. This ticket will show up in Atera just as if a user submitted it. Combining this with earlier sections, you might create a ticket when a certain alert is generated or when a script detects an anomaly ‚Äì automating your incident creation process. d. Additional Ticket Operations: The API also allows retrieving ticket comments and time entries, which can be useful for reporting or syncing with other systems. For example:
Get comments on a ticket: GET /api/v3/tickets/{ticketId}/comments will return an array of comment objects (with author, timestamp, content). You could use this to, say, migrate ticket conversations to another platform or analyze response times.
Get work hours (time logs) on a ticket: GET /api/v3/tickets/{ticketId}/workhoursrecords returns time entry records (each containing hours, work description, whether billed, etc.)
github.com
. This is useful if you want to compile timesheet reports or verify if a ticket‚Äôs time has been invoiced (there‚Äôs no direct flag for invoicing in the ticket, but you could cross-reference the billing module or use the workhoursrecords and workhours endpoints along with the invoice data)
atera.uservoice.com
.
Currently, adding a new comment via API is not explicitly documented (there isn‚Äôt a direct POST /comments endpoint in the v3 docs). However, you can include a public note or update to the ticket via the PUT /tickets call (for example, updating the TicketDescription or a custom field could serve to log a note). For robust use, it‚Äôs best to handle ticket comments through the UI or the email loop, unless Atera extends the API with comment creation.
5. Triggering or Scheduling Scripts on Endpoints
As noted earlier, the Atera API does not yet provide a direct endpoint to remotely execute scripts on an agent on-demand. Script execution in Atera is normally done by assigning scripts to an Automation Profile (which can run on a schedule or triggered by certain events)
support.atera.com
. Therefore, you can‚Äôt, for example, call POST /api/v3/agents/{id}/runscript (such an endpoint doesn‚Äôt exist as of now). However, there are still ways to integrate scripting with the API:
Using the API within Scripts: Atera allows running PowerShell scripts on endpoints (via the agent). Within those scripts, you can call Atera‚Äôs API (since you have networking and the API key). For instance, a script running on an agent could fetch data from Atera: perhaps it gets a stored password or license key from a custom field via Get-AteraCustomValue (as in the Sophos deployment example)
support.atera.com
, or it could update its own status by calling the API (e.g. creating an alert or updating a custom field to signal completion). To do this, you would embed the API key in your script or retrieve it securely, then use Invoke-RestMethod calls just like from any PowerShell environment. Example: The snippet below (adapted from an Atera community script) runs on an agent to get a custom field value and then uses it in installation of software:
# Inside a script running on an Atera-monitored machine:
$AteraAPIKey = 'YOUR_API_KEY'    # In practice, secure this key appropriately
$fieldName   = 'Sophos Key'     # Custom field name to retrieve from Customer

# Prepare header and get this device's info (to find associated CustomerID)
$headers = @{ "X-API-KEY" = $AteraAPIKey; "Accept" = "application/json" }
$thisAgent = Invoke-RestMethod -Uri "https://app.atera.com/api/v3/agents/machine/$(hostname)" -Headers $headers -Method GET
$customerId = $thisAgent.items[0].CustomerID

# Get the custom field value for this customer (e.g., a license key stored at customer level)
$url = "https://app.atera.com/api/v3/customvalues/customerfield/$customerId/$(Uri.EscapeDataString($fieldName))"
$customFieldValue = Invoke-RestMethod -Uri $url -Headers $headers -Method GET
$licenseKey = $customFieldValue.ValueAsString

Write-Host "Retrieved license key from Atera:" $licenseKey
# (Proceed to use $licenseKey in installation command, etc.)
Explanation: We use the machine‚Äôs hostname to find the agent record via API, then use its CustomerID to fetch a customer-level custom field called "Sophos Key". This returns an object with the value (in ValueAsString). We then would use that value (here a Sophos AV license token) in some installation command. This demonstrates how the API can enhance scripts with dynamic data from Atera.
Scheduling scripts via API (indirect): While you cannot directly schedule via API, you could script the creation of a one-time Automation Profile assignment if such endpoints existed. Currently, Atera‚Äôs API does not include endpoints to create or assign automation profiles. So an alternative approach is to maintain your own schedule externally and use the API plus remote scripting: e.g., have a PowerShell script (outside Atera) that runs on a schedule, fetches a list of devices from Atera, then uses another mechanism (like PowerShell Remoting, or Atera‚Äôs own Run Script manual trigger via UI) to execute tasks on those devices. It‚Äôs a bit out-of-scope for the API, but it highlights that the API can retrieve the targets and data, and you can use other means to run the payload on endpoints.
Logging script results: Another integration strategy is using the API to log the outcome of scripts. For example, if a script (run via Automation Profile or manually) encounters an issue it can‚Äôt fix, it could call POST /api/v3/tickets to open a ticket with details, or POST /api/v3/alerts to raise an alert for attention. This way, even though the API didn‚Äôt execute the script, it helps in follow-up actions.
In short, triggering scripts is mainly a UI-driven feature in Atera, but the API is complementary ‚Äì it supplies input data to scripts and accepts output (in form of alerts/tickets/field updates) from scripts. Administrators typically upload their PowerShell scripts to Atera‚Äôs script library and then assign them via the web UI to run on a schedule
support.atera.com
. Once (or if) Atera exposes scripting control via API, direct script triggers will become possible; until then, consider the API and scripting as two pieces of the automation puzzle that you can connect creatively (as shown above).
6. Accessing Reports and Usage Data
While Atera‚Äôs API doesn‚Äôt have explicit ‚Äúreport‚Äù endpoints, you can gather data for reports as demonstrated in previous sections. Here are a few examples of how you might use the API for reporting or analysis:
Agent Status Summary: Using the device data from the Agents API, you could compile a report of how many devices are online vs offline, what OS versions are in use, or which devices haven‚Äôt been seen recently. The agent data includes fields like LastSeen or last modified timestamps (Modified), which you could use to identify stale devices. For instance, you might filter $agents (from example 2) for $_.Online -eq $false to list offline machines, or sort by LastPatchManagementReceived to see which machines haven‚Äôt received patches in a long time.
Alerts Dashboard: By pulling alerts via API, you can create a real-time dashboard of active alerts. You might categorize them by severity, customer, or type. Because the API provides the alert details including the message and associated device, you can display these in a NOC (Network Operations Center) dashboard or send them to a team chat. Atera‚Äôs FAQ even suggests using the API to show alerts on a TV dashboard in your office
support.atera.com
.
Ticket Metrics: You can gather ticket data to generate helpdesk metrics ‚Äì for example, count how many tickets were created versus resolved in the last month. Using the tickets/statusmodified endpoint, you can retrieve tickets that were closed within a certain timeframe
github.com
. Additionally, by using the CustomerId filter, you could produce per-customer ticket counts. Here‚Äôs a brief example to count resolved tickets in the past 7 days:
# Get all resolved tickets (could also filter by date after retrieval)
$resolvedTickets = Invoke-RestMethod -Uri "https://app.atera.com/api/v3/tickets?ticketStatus=Resolved" -Headers $headers
$recentResolved = @($resolvedTickets.items) | Where-Object { $_.TicketResolvedDate -gt (Get-Date).AddDays(-7) }
Write-Host "Tickets resolved in the last 7 days:" $recentResolved.Count
This fetches all resolved tickets (note: if there are many, you‚Äôd paginate; for clarity we assume it‚Äôs manageable). Then it filters by TicketResolvedDate. Each ticket object has TicketResolvedDate and TicketCreatedDate which you can use for SLA calculations or volume trends
support.atera.com
. For more detailed reporting, you might export this data to CSV or use Power BI. In fact, many users integrate Power BI with Atera‚Äôs API to visualize such metrics, leveraging the same API calls shown here
community.atera.com
community.atera.com
.
Billing and Time Tracking: Using the billing and ticket work hours endpoints, you can create reports on how many hours were logged for each customer or project, and which have been invoiced. For example, after retrieving work hour records (/tickets/{id}/workhoursrecords), you could sum hours per ticket or customer. The invoice endpoints (/billing/invoices) let you correlate ticket time entries with invoice numbers if needed (though deep integration may require exporting and matching IDs).
Software/Asset Information: Although the API doesn‚Äôt directly list installed software on devices (that data isn‚Äôt exposed yet
community.atera.com
community.atera.com
), you can still gather asset information like hardware specs, OS versions, and missing patches (indirectly via last patch date or by deploying a script to collect software and then sending it back). For now, any software deployment status would be gleaned via script outputs or alerts.
In generating reports, remember to respect the API rate limits (e.g. ~400 requests/min for entry-level subscriptions)
support.atera.com
 ‚Äì which is usually plenty. If you are pulling thousands of records, just ensure your loop adds a small delay if needed or that you use efficient paging (50 at a time).
7. Example ‚Äì End-to-End Automation Scenario
To tie everything together, consider a practical automation scenario: automated remediation of a disk space alert. Here‚Äôs how Atera API and PowerShell could work together in such a case:
Detection: Atera‚Äôs monitoring generates an alert that a server‚Äôs disk is low on space (say AlertID 555 with Title ‚ÄúC: Drive Low Space‚Äù).
Alert Ingestion: We have a PowerShell script running externally (could be a scheduled script on a local server or Azure Function) that periodically checks for new alerts via GET /api/v3/alerts. It finds the low-space alert.
Remediation Action: The script parses the alert‚Äôs DeviceName or AgentID, uses GET /api/v3/agents/{agentId} to fetch the device details (like last logged on user or IP if needed). It then remotely connects to the device (e.g., via PowerShell Remoting or an RMM script) to perform a cleanup ‚Äì maybe delete temp files. Alternatively, the script could leverage Atera‚Äôs automation by creating a one-time script task: since no direct API for that, it might instead create a ticket to notify a tech or trigger a human action if fully automated cleanup isn‚Äôt possible.
Resolution and Logging: If the cleanup succeeds and frees space, the script could then resolve the alert via DELETE /api/v3/alerts/555. It might also update or close the ticket that was tracking this issue using PUT /api/v3/tickets/{ticketId} (if a ticket was created). If a ticket wasn‚Äôt created, the script could generate one to document the action after the fact. The script could also post a comment (currently by adding to the ticket description or a custom field) about what was done.
While step 3 involves actions outside the Atera API (actual disk cleanup on the device), the API was crucial for retrieving the alert and device info and for updating Atera (clearing the alert, logging the results). This hybrid approach highlights how the API extends Atera‚Äôs automation capabilities beyond what‚Äôs possible through the UI alone.
References: All the above examples and capabilities are based on Atera‚Äôs official API documentation and support articles. The Atera API (v3) documentation confirms the available endpoints for agents, alerts, tickets, contacts, customers, devices, etc., and the allowed operations (GET/POST/PUT/DELETE) for each
support.atera.com
support.atera.com
support.atera.com
. We also used insights from Atera‚Äôs community and knowledge base (for instance, about using the API key, pagination, and custom script usage) to ensure the examples are accurate and practical. For further details, you can refer to Atera‚Äôs API reference on their website (accessible via Admin > API Documentation in the Atera console) and their API FAQ
support.atera.com
support.atera.com
. The PowerShell code leverages standard REST calls; you may also consider the community-developed PSAtera PowerShell module which wraps many of these API calls into simple cmdlets
support.atera.com
support.atera.com
. Combining Atera‚Äôs API with PowerShell opens up a world of automation possibilities ‚Äì from syncing data to orchestrating complex workflows ‚Äì thereby supercharging your IT management processes.





Sources
You said:
How frequently can we poll atera for device info using the api? Is there a limit of api requests?
ChatGPT said:
Are you looking for general rate limits across all endpoints, or specifically for polling agent/device information (e.g., /agents or /agents/{id})? Also, is your use case for polling a few devices frequently or polling the full inventory at intervals? This will help determine how to approach Atera's API rate limits and best practices.

You said:
specifically for polling agent/device information (e.g., /agents or /agents/{id}
ChatGPT said:
Understood. I will investigate the API rate limits specifically related to polling Atera agent/device information (such as the /api/v3/agents and /api/v3/agents/{id} endpoints). This includes any documented frequency limits, throttling policies, and best practices for safely polling device data without triggering restrictions.

I'll report back with details shortly.

You said:
try again
ChatGPT said:
Here‚Äôs what I found regarding Atera RMM API rate limits and polling frequency for agent/device endpoints:

‚ö° API Request Rate Limits by Subscription Tier
According to Atera‚Äôs official FAQ, your rate limit depends on your subscription level:

Lower-tier (entry-level) plans: up to 400 requests/minute

Expert plans: up to 2,000 RPM

Master tier (higher-tier customers): up to 4,000 RPM 
Atera Support
+10
Atera Support
+10
Reddit
+10
Atera
+1
Cynet
+1

These limits are aggregate across all API endpoints‚Äîtickets, alerts, agents, custom values, etc.‚Äîand apply consistently to polling or any usage.

üîç Polling Device/Agent Endpoints
Are /agents and /agents/{id} handled differently?
No, Atera treats these the same as other endpoints. You consume your RPM allowance whether you're polling all agents or querying individual agents.

What happens if you exceed the limit?
If you exceed your rate limit, you‚Äôll receive HTTP 429 Too Many Requests responses. Per support documentation, the limit is enforced over a 1-hour window. Repeated violations may result in temporary throttling or paused access for the remainder of the hour. 
Atera Support
Atera Support

üïí Recommended Polling Frequencies
For full inventory polling (GET /agents):
If you‚Äôre on a 400 RPM plan, polling once per minute is safe (one request returns up to ~50 agents).

For 2,000‚Äì4,000 RPM tiers, you could potentially poll every 10‚Äì15‚ÄØseconds if necessary‚Äîbut in practice, such frequency is rarely needed.

For individual agent polling (/agents/{id}):
You can call this more frequently, but overall calls still count toward your RPM limit.

Polling dozens of individual agents at high frequency can consume your quota quickly.

Best practices:
Use the paginated /agents?page=&itemsInPage= endpoint to retrieve multiple records per request.

Cache responses locally and only re-query when needed instead of polling continuously.

Consider polling less frequently (e.g. every 1‚Äì5 minutes) unless real-time status changes are critical.

‚úÖ Summary Table
Plan Tier	Max API Calls / Minute	Recommended Polling Strategy for /agents
Entry-level (400 RPM)	~400	Poll once per minute if only full inventory calls
Expert (2,000 RPM)	~2,000	Poll every 10‚Äì30s if needed, or full sync every minute
Master (4,000 RPM)	~4,000	Multiple frequent calls OK, but use batching wisely
All calls‚Äîincluding agents, alerts, tickets‚Äîcount toward the same rate limit.

üîß Practical Polling Example in PowerShell
# Define plan limit
$maxPerMinute = 400     # adjust for your subscription (400 / 2000 / 4000)

# Function to get agents, with built-in throttle
function Get-AteraAgents-Throttled {
    param(
        [int]$page = 1, [int]$pageSize = 50
    )
    # Pause to not exceed rate
    Start-Sleep -Milliseconds ([int](60000 / $maxPerMinute))
    $uri = "https://app.atera.com/api/v3/agents?page=$page&itemsInPage=$pageSize"
    return Invoke-RestMethod -Uri $uri -Headers $headers -Method GET
}

# Example usage: retrieve full inventory at safe pace
$allAgents = @()
$page = 1
do {
    $resp = Get-AteraAgents-Throttled -page $page -pageSize 50
    $allAgents += $resp.items
    $page++
} while ($resp.nextLink -ne $null)

Write-Host "Total agents loaded:" $allAgents.Count
This script respects rate limits by spacing requests evenly over the minute. Flex the $maxPerMinute value to match your account‚Äôs plan.

üö® Final Notes
All endpoints consume from the same pool of allowable requests per minute.

Exceeding the limit triggers HTTP 429 responses, and your access may be temporarily halted for the duration of the hour.

There's no separate per-endpoint allowance‚Äîuse paging and throttling logic to make polling efficient and safe.

Let me know if you‚Äôd like help building adaptive throttling logic or optimizing polling intervals for your specific use case.

You said:
Can I send a reboot command using the API?
ChatGPT said:
You cannot send a reboot or remote shutdown command via the Atera RMM API. The public API does not include endpoints to reboot, restart, log out, or shut down a device.

‚úÖ What‚Äôs Supported
Reboot actions are managed exclusively within the Atera UI, particularly under Patch Management and Device Management.

You can schedule or trigger reboots via the Atera console:

Go to the Patch Management dashboard under "Devices pending restart" for multi-device reboots.

Or use the Devices page ‚Üí Manage ‚Üí Shutdown Actions ‚Üí Restart, Shut down, or Log out to initiate or schedule a reboot manually‚ÄÇ
Reddit
+12
Atera Support
+12
docs.coro.net
+12
Atera Support
.

üö´ Limitations of the API
There is no REST endpoint such as POST /agents/{id}/reboot or anything equivalent.

Neither mass nor single rebooting via API is supported; operations like reboot are only available through the Atera web interface.‚ÄÇ
Atera Support
Atera Support
.

üîÅ Workarounds
If you need to automate a reboot, here are viable alternatives:

Use Atera Automation Profiles

Within the Automation Profile (configured via UI), select the ‚ÄúReboot if needed‚Äù option. Atera will reboot devices automatically if patching or script tasks require it‚ÄÇ
atera.uservoice.com
Atera Support
+13
Atera Support
+13
Atera
+13
.

Run a custom PowerShell restart script via an Automation Profile

Upload a PowerShell script to your script library that runs Restart-Computer locally on the agent.

Assign that script to run on-target devices via an automation profile.

Local script execution via PowerShell Remoting or other tooling

If your environment supports remote management, you can push a Restart-Computer command outside of Atera.

Trigger remediation flow via API

Although the API can‚Äôt initiate a reboot directly, you can poll device state via /agents, detect issues like offline status or outdated patch info, then:

Create a ticket via API to notify a tech to reboot

Or create a custom alert to drive manual or script-scheduled action‚ÄÇ
Atera Support
atera.uservoice.com
.

üß≠ Summary Table
Feature	Supported Via API?	How to Reboot
Single device reboot	‚ùå No	UI or Automation Profile script
Scheduled reboot	‚ùå No	UI-driven scheduling
"Reboot if needed"	‚ùå No (via API)	Automation Profile option
Creating custom alert	‚úÖ Yes	Use API to alert tech
Creating support ticket	‚úÖ Yes	Use API to notify or document
If reboot needs to be automated at scale, the best route is via Automation Profiles in the Atera UI‚Äîselect the "Reboot if needed" option or attach a custom restart script to profiles. While the API doesn't provide direct reboot control, you can build surrounding automation flows (detection ‚Üí ticket/alert ‚Üí remediation) to address reboot requirements. Let me know if you'd like help creating a PowerShell script for the UI-run reboot task.

You said:
Can I remove a device using the api
ChatGPT said:
Yes, you can remove a device from Atera using the API‚Äîbut only agent-installed devices, not SNMP or monitored network devices.

‚úÖ To Remove an Agent (Monitored Device with Atera Agent Installed)
You can use:

DELETE /api/v3/agents/{agentId}
Requirements:
You must know the agentId of the device.

The API key must have permissions to perform the delete action.

PowerShell Example:
$ateraApiKey = "YOUR_API_KEY"
$headers = @{
    "X-API-KEY" = $ateraApiKey
    "Accept"    = "application/json"
}

$agentId = 123456  # Replace with actual agent ID
$url = "https://app.atera.com/api/v3/agents/$agentId"

Invoke-RestMethod -Uri $url -Method DELETE -Headers $headers
Write-Host "Agent ID $agentId has been removed from Atera."
‚ö†Ô∏è Notes:
This does not uninstall the agent from the machine. It only removes the device from your Atera portal.

If the agent is still installed, it will reappear the next time it checks in.

To fully decommission, you must uninstall the Atera agent locally on the machine (Control Panel, Add/Remove Programs, or via script).

‚ùå To Remove a SNMP or Network-Only Device
Use the appropriate endpoint based on device type:

Device Type	Remove Endpoint
SNMP v1/v2/v3	DELETE /api/v3/devices/snmpdevice/{id}
HTTP monitor	DELETE /api/v3/devices/httpdevice/{id}
TCP monitor	DELETE /api/v3/devices/tcpdevice/{id}
Generic monitor	DELETE /api/v3/devices/genericdevice/{id}
You need the device ID or GUID from a prior GET query to execute the delete.

üßæ Summary
Device Type	Removable via API	Endpoint
Atera Agent Device	‚úÖ	DELETE /api/v3/agents/{agentId}
SNMP Device	‚úÖ	DELETE /api/v3/devices/snmpdevice/{id}
HTTP/TCP Device	‚úÖ	Corresponding DELETE endpoint
Uninstall Agent	‚ùå	Must be done manually or via script
Let me know if you want an uninstall script or a full cleanup workflow.



No file chosenNo file chosen
ChatGPT can make mistakes. Check important info.
